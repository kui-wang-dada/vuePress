<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器的执行顺序和结构 | 哒哒的博客</title>
    <meta name="description" content="哒哒练习写文章做记录的地方">
    <link rel="icon" href="/blog/img/logo.png">
    
    <link rel="preload" href="/blog/assets/css/0.styles.99707b60.css" as="style"><link rel="preload" href="/blog/assets/js/app.04a40249.js" as="script"><link rel="preload" href="/blog/assets/js/2.614c271f.js" as="script"><link rel="preload" href="/blog/assets/js/3.cabfff8b.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.4b36cd09.js"><link rel="prefetch" href="/blog/assets/js/11.2d5a8e9e.js"><link rel="prefetch" href="/blog/assets/js/12.5f3cf8ed.js"><link rel="prefetch" href="/blog/assets/js/13.44a80d36.js"><link rel="prefetch" href="/blog/assets/js/14.25295f21.js"><link rel="prefetch" href="/blog/assets/js/15.c62c6c25.js"><link rel="prefetch" href="/blog/assets/js/16.8a80f0bf.js"><link rel="prefetch" href="/blog/assets/js/17.f5d28493.js"><link rel="prefetch" href="/blog/assets/js/18.1dfd5511.js"><link rel="prefetch" href="/blog/assets/js/19.966ec7fb.js"><link rel="prefetch" href="/blog/assets/js/20.f8046668.js"><link rel="prefetch" href="/blog/assets/js/21.b6ee572b.js"><link rel="prefetch" href="/blog/assets/js/22.8be287c5.js"><link rel="prefetch" href="/blog/assets/js/23.0447c120.js"><link rel="prefetch" href="/blog/assets/js/24.ba0460c9.js"><link rel="prefetch" href="/blog/assets/js/25.dd78291e.js"><link rel="prefetch" href="/blog/assets/js/26.3a365eb0.js"><link rel="prefetch" href="/blog/assets/js/27.94f729a2.js"><link rel="prefetch" href="/blog/assets/js/28.b2cbe28d.js"><link rel="prefetch" href="/blog/assets/js/29.4ec1cf2a.js"><link rel="prefetch" href="/blog/assets/js/30.efc3e4ac.js"><link rel="prefetch" href="/blog/assets/js/31.8224951a.js"><link rel="prefetch" href="/blog/assets/js/32.6e850d41.js"><link rel="prefetch" href="/blog/assets/js/33.84383827.js"><link rel="prefetch" href="/blog/assets/js/34.b494f796.js"><link rel="prefetch" href="/blog/assets/js/35.ee0a06bd.js"><link rel="prefetch" href="/blog/assets/js/36.a9c9dd98.js"><link rel="prefetch" href="/blog/assets/js/37.5cd39c31.js"><link rel="prefetch" href="/blog/assets/js/38.7f6c4fc2.js"><link rel="prefetch" href="/blog/assets/js/4.b0d7986b.js"><link rel="prefetch" href="/blog/assets/js/5.6030204f.js"><link rel="prefetch" href="/blog/assets/js/6.be32cf31.js"><link rel="prefetch" href="/blog/assets/js/7.c65ec4e3.js"><link rel="prefetch" href="/blog/assets/js/8.7f5e33b9.js"><link rel="prefetch" href="/blog/assets/js/9.e1c65847.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.99707b60.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">哒哒的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">JS基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/JS/object.html" class="nav-link">JS之面向对象程序设计和继承</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/write.html" class="nav-link">手写代码系列</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/base.html" class="nav-link">JS基础知识总结</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/copy.html" class="nav-link">JS深浅拷贝</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/design.html" class="nav-link">JS设计模式</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/this.html" class="nav-link">JS之this指向</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/ifelse.html" class="nav-link">JS条件语句</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/simple.html" class="nav-link">JS之代码简洁之道</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">框架+App</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/app/vue.html" class="nav-link">vue基础知识</a></li><li class="dropdown-item"><!----> <a href="/blog/app/vuex.html" class="nav-link">vuex基础</a></li><li class="dropdown-item"><!----> <a href="/blog/app/cordova.html" class="nav-link">cordova基础</a></li><li class="dropdown-item"><!----> <a href="/blog/app/vueCordova.html" class="nav-link">vue+cordova思考</a></li><li class="dropdown-item"><!----> <a href="/blog/app/RNSummary.html" class="nav-link">ReactNative技术栈总结</a></li><li class="dropdown-item"><!----> <a href="/blog/app/RNRecord.html" class="nav-link">ReactNative知识点记录</a></li><li class="dropdown-item"><!----> <a href="/blog/app/flutter_1.html" class="nav-link">flutter学习笔记</a></li><li class="dropdown-item"><!----> <a href="/blog/app/uniapp.html" class="nav-link">小程序多端框架研究</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/Node/koa2.html" class="nav-link">koa2+sequelize初探</a></li><li class="dropdown-item"><!----> <a href="/blog/Node/fullStack.html" class="nav-link">全栈工程思考</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">浏览器</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/web/http.html" class="nav-link">http协议总结</a></li><li class="dropdown-item"><!----> <a href="/blog/web/web_1.html" class="nav-link router-link-exact-active router-link-active">浏览器的执行顺序和结构1</a></li><li class="dropdown-item"><!----> <a href="/blog/web/web_2.html" class="nav-link">浏览器的执行顺序和结构2</a></li><li class="dropdown-item"><!----> <a href="/blog/web/font-end.html" class="nav-link">前端转行心得</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">构建</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/goujian/webpack.html" class="nav-link">webpack学习</a></li><li class="dropdown-item"><!----> <a href="/blog/goujian/cli.html" class="nav-link">从零搭建一个脚手架</a></li><li class="dropdown-item"><!----> <a href="/blog/goujian/docker.html" class="nav-link">docker学习笔记</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/base/computer.html" class="nav-link">计算机基础</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">JS基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/JS/object.html" class="nav-link">JS之面向对象程序设计和继承</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/write.html" class="nav-link">手写代码系列</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/base.html" class="nav-link">JS基础知识总结</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/copy.html" class="nav-link">JS深浅拷贝</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/design.html" class="nav-link">JS设计模式</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/this.html" class="nav-link">JS之this指向</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/ifelse.html" class="nav-link">JS条件语句</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/simple.html" class="nav-link">JS之代码简洁之道</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">框架+App</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/app/vue.html" class="nav-link">vue基础知识</a></li><li class="dropdown-item"><!----> <a href="/blog/app/vuex.html" class="nav-link">vuex基础</a></li><li class="dropdown-item"><!----> <a href="/blog/app/cordova.html" class="nav-link">cordova基础</a></li><li class="dropdown-item"><!----> <a href="/blog/app/vueCordova.html" class="nav-link">vue+cordova思考</a></li><li class="dropdown-item"><!----> <a href="/blog/app/RNSummary.html" class="nav-link">ReactNative技术栈总结</a></li><li class="dropdown-item"><!----> <a href="/blog/app/RNRecord.html" class="nav-link">ReactNative知识点记录</a></li><li class="dropdown-item"><!----> <a href="/blog/app/flutter_1.html" class="nav-link">flutter学习笔记</a></li><li class="dropdown-item"><!----> <a href="/blog/app/uniapp.html" class="nav-link">小程序多端框架研究</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/Node/koa2.html" class="nav-link">koa2+sequelize初探</a></li><li class="dropdown-item"><!----> <a href="/blog/Node/fullStack.html" class="nav-link">全栈工程思考</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">浏览器</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/web/http.html" class="nav-link">http协议总结</a></li><li class="dropdown-item"><!----> <a href="/blog/web/web_1.html" class="nav-link router-link-exact-active router-link-active">浏览器的执行顺序和结构1</a></li><li class="dropdown-item"><!----> <a href="/blog/web/web_2.html" class="nav-link">浏览器的执行顺序和结构2</a></li><li class="dropdown-item"><!----> <a href="/blog/web/font-end.html" class="nav-link">前端转行心得</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">构建</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/goujian/webpack.html" class="nav-link">webpack学习</a></li><li class="dropdown-item"><!----> <a href="/blog/goujian/cli.html" class="nav-link">从零搭建一个脚手架</a></li><li class="dropdown-item"><!----> <a href="/blog/goujian/docker.html" class="nav-link">docker学习笔记</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/base/computer.html" class="nav-link">计算机基础</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>浏览器的执行顺序和结构</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/web/web_1.html#浏览器的执行顺序和结构" class="sidebar-link">浏览器的执行顺序和结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/web_1.html#一-什么是进程，什么是线程" class="sidebar-link">一. 什么是进程，什么是线程</a></li><li class="sidebar-sub-header"><a href="/blog/web/web_1.html#二-浏览器使用什么架构" class="sidebar-link">二. 浏览器使用什么架构</a></li><li class="sidebar-sub-header"><a href="/blog/web/web_1.html#三、输入-url-后浏览器是如何处理的" class="sidebar-link">三、输入 URL 后浏览器是如何处理的</a></li><li class="sidebar-sub-header"><a href="/blog/web/web_1.html#四、javascript-在浏览器中是如何执行的" class="sidebar-link">四、javascript 在浏览器中是如何执行的</a></li><li class="sidebar-sub-header"><a href="/blog/web/web_1.html#四、-v8-工作原理" class="sidebar-link">四、 V8 工作原理</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="浏览器的执行顺序和结构"><a href="#浏览器的执行顺序和结构" aria-hidden="true" class="header-anchor">#</a> 浏览器的执行顺序和结构</h2> <h3 id="一-什么是进程，什么是线程"><a href="#一-什么是进程，什么是线程" aria-hidden="true" class="header-anchor">#</a> 一. 什么是进程，什么是线程</h3> <p>并行处理：同一时刻处理多个任务，使用并行处理能大大提升性能</p> <p>进程：并发执行程序的执行过程中资源分配和管理的基本单位</p> <p>进程类似于工厂，是一个程序的运行实例，操作系统会为该程序创建内存，存放代码，运行中的数据和一个执行任务的主线程，这样的运行环境叫进程</p> <p>线程：程序执行的最小单位</p> <p>线程类似于工厂里的人，依附进程，不能单独存在，由进程来启动和管理。多线程并行处理能提升运算效率</p> <p>进程和线程之间的关系有四个特点：</p> <ol><li><p>进程中的任意一线程执行出错，都会导致整个进程的崩溃。类似于人疯了，工厂就停产了</p></li> <li><p>线程之间共享进程中的数据。 类似于每个人都可以使用工厂的资源</p></li> <li><p>当一个进程关闭之后，操作系统会回收进程所占用的内存。 类似于工厂倒闭了，国家收回工厂剩下的材料</p></li> <li><p>进程之间的内容互相隔离。 类似于工厂之间是隔离的，互相不知道各自的资源和行为方式，但可以通过出厂交流来通信</p></li></ol> <h3 id="二-浏览器使用什么架构"><a href="#二-浏览器使用什么架构" aria-hidden="true" class="header-anchor">#</a> 二. 浏览器使用什么架构</h3> <p>单进程：
早期（2007 年以前），浏览器的所有功能模块都运行在同一个进程里，包括网络，插件，js 运行环境，渲染引擎和页面等
问题：不稳定，一个线程崩溃导致整个浏览器的崩溃
不流畅，每个线程负责的功能多，如渲染，js 执行和插件都是运行在一个线程中，同一时刻只能有一个模块可以执行
不安全，插件和页面脚本也能访问进程中的数据</p> <p>多进程
2008 年以后，chrome 形成如下的架构</p> <p><img src="/blog/assets/img/41.cdc9215e.png" alt="1.jpeg"></p> <p>每个页面运行在单独的渲染进程中，页面的插件也是运行在单独的插件进程中，进程之间通过 IPC 机制进行通信</p> <p>目前的多进程架构</p> <p><img src="/blog/assets/img/42.b61cab52.png" alt="2.jpeg"></p> <ul><li>浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li> <li>渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li> <li>GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li> <li>网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li> <li>插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul> <h3 id="三、输入-url-后浏览器是如何处理的"><a href="#三、输入-url-后浏览器是如何处理的" aria-hidden="true" class="header-anchor">#</a> 三、输入 URL 后浏览器是如何处理的</h3> <p><img src="/blog/assets/img/43.92d73c75.png" alt="3.jpeg"></p> <p>整个过程需要各个进程之间的配合：</p> <ul><li>浏览器进程主要负责用户交互、子进程管理和文件储存等功能。</li> <li>网络进程是面向渲染进程和浏览器进程等提供网络下载功能。</li> <li>渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全</li></ul> <ol><li>用户输入</li></ol> <ul><li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，</li> <li>如果输入内容符合 URL 规则，浏览器会根据规则，给内容加上协议，浏览器进程进入加载状态</li></ul> <ol start="2"><li>URL 请求过程</li></ol> <ul><li>浏览器进程会通过 IPC 把 URL 请求发给网络进程</li> <li>网络进程查找本地是否缓存了资源，若有，直接返回资源，若没有，进入请求流程</li> <li>DNS 解析，若有 DNS 缓存，直接用，若没有，会向 DNS 服务器请求</li> <li>建立 TCP 连接，三次握手</li> <li>浏览器构建请求行，请求头，cookie 等信息，向服务器发送构建的请求</li> <li>服务器接收到请求，会根据请求信息生成相应数据（行，头，体），并发给浏览器的网络进程</li> <li>浏览器接收到服务器的响应头后，网络进程开始解析，如果发现返回的状态吗是 301 或 302，会重定向</li> <li>网络进程从响应头的 location 读取重定向的地址，然后重新发起新的 http 或者 https 请求，一切从头开始</li></ul> <ol start="3"><li>准备渲染进程
默认情况下，chrome 会为每个页面分配一个渲染进程；但如果从一个页面打开另一个新页面，新页面和当前页面属于同一站点的话，新页面会复用父页面的渲染进程</li></ol> <ul><li>网络进程读取响应头信息后，会告知浏览器进程准备</li> <li>浏览器进程准备渲染进程，并向渲染进程发出‘提交文档’的指令</li> <li>渲染进程收到后，会和网络进程建立传输数据的“管道”</li> <li>文档数据传输完成之后，渲染进程会返回“确认提交”的指令给浏览器进程</li> <li>浏览器收到后，会更新浏览器界面状态</li></ul> <ol start="4"><li>渲染阶段</li></ol> <ul><li>构建 dom 树，将 html 转换为浏览器能理解的结构</li> <li>样式计算，将 css 转换为浏览器理解的结构；转换属性，使其标准化；计算 dom 树中每个节点的具体样式</li> <li>布局阶段：创建布局树，布局计算</li> <li>分层：类似于图层，根据布局树各节点的属性判断</li> <li>绘制：把一个图层的绘制拆分很多小的指令，然后把这些指令按照顺序组成一个待绘制的列表</li> <li>栅格化操作，此时具体绘制工作交给了合成线程来操作，合成线程会将图层分为图块，图层是横向的，图块是纵向纬度，合成线程按照视口附近的图块优先生成位图，图块变位图是有 GPU 生成的，GPU 又是在 GPU 进程中，因此合成线程主要起调度作用，真正合成位图是有 GPU 进程完成的。</li> <li>位图全部生成后，合成线程发出一个指令给浏览器进程，浏览器将页面内容绘制到内存中，最后再将内存显示在屏幕上。</li></ul> <p><img src="/blog/assets/img/44.975fcbf7.png" alt="4.jpeg"></p> <h3 id="四、javascript-在浏览器中是如何执行的"><a href="#四、javascript-在浏览器中是如何执行的" aria-hidden="true" class="header-anchor">#</a> 四、javascript 在浏览器中是如何执行的</h3> <h4 id="_1-变量提升"><a href="#_1-变量提升" aria-hidden="true" class="header-anchor">#</a> 1. 变量提升</h4> <p>在 js 代码执行过程中，js 引擎把变量的声明部分和函数的声明部分提升到代码开头的行为</p> <ul><li>一段 js 代码在执行前需要被 js 引擎编译，再执行</li> <li>编译阶段，会在执行环境中产生变量环境和可执行代码
<img src="/blog/assets/img/45.0655d18e.png" alt="5.jpeg"></li></ul> <h4 id="_2-栈溢出"><a href="#_2-栈溢出" aria-hidden="true" class="header-anchor">#</a> 2. 栈溢出</h4> <p>js 中有很多函数，经常出现一个函数中调用另一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构</p> <p>什么是栈？：一种满足后进先出的数据结构</p> <p>什么是 js 的调用栈：js 利用栈管理执行上下文，js 引擎会将创建好的执行上下文压入栈中</p> <p>所以全局上下文在最底层，随着 js 执行，不断有执行上下文推入到调用栈中，若有函数调用函数，就继续推入，执行后退出，再加入新的执行上下文。</p> <p><img src="/blog/assets/img/46.ccfe41d9.png" alt="6.jpeg"></p> <p>由于调用栈是有大小的，所以当入栈的执行上下文超过一定数目，js 引擎就会报错，这种错误就是栈溢出，入终止条件不合适的递归函数。</p> <h4 id="_3-作用域"><a href="#_3-作用域" aria-hidden="true" class="header-anchor">#</a> 3. 作用域</h4> <p>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。</p> <ul><li>全局作用域：对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期</li> <li>函数作用域：函数内部的变量或者函数，只能在内部被访问，函数执行结束后，变量会被销毁</li></ul> <p>js 引入了变量提升机制，没有块级作用域；</p> <ul><li>变量容易在不被察觉的情况下被覆盖掉</li> <li>本应销毁的变量没有被销毁</li></ul> <p>加入了 let 和 const ，实现块级作用域</p> <ul><li>函数内部通过 var 声明的变量，在编译阶段全都存放到变量环境中</li> <li>通过 let 或 const 声明的变量，在编译阶段会被存放到词法环境中</li> <li>作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独区域
<img src="/blog/assets/img/47.06c06a75.png" alt="7.jpeg"></li></ul> <h4 id="_4-作用域链和闭包"><a href="#_4-作用域链和闭包" aria-hidden="true" class="header-anchor">#</a> 4. 作用域链和闭包</h4> <p>其实每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文；</p> <p>当函数中使用了外部变量，会向外部引用查找，这样的一个查找链条就成为作用域链</p> <blockquote><p>词法作用域：静态作用域，由代码中函数声明的位置决定的</p></blockquote> <p><img src="/blog/assets/img/48.87d8bbc2.png" alt="8.jpeg"></p> <p>上图中 bar 函数和 foo 函数的外部引用都是指向全局，因为其定义的地方是在全局下</p> <p>因此词法作用域是代码阶段就决定好的，和函数如何调用没有关系。</p> <p>块级作用域+作用域链条</p> <p><img src="/blog/assets/img/49.25053af5.png" alt="9.jpeg"></p> <blockquote><p>闭包：根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。</p></blockquote> <h4 id="_5-this"><a href="#_5-this" aria-hidden="true" class="header-anchor">#</a> 5. this</h4> <blockquote><p>在对象内部的方法中访问对象内部的属性是一个非常普遍的需求，因此 js 引入了 this 机制</p></blockquote> <p>执行上下文都有一个 this</p> <p>而执行上下文分为全局和函数</p> <ul><li>全局中的 this 指向 window；</li> <li>当函数作为对象的方法调用时，函数中的 this 就是该对象；</li> <li>当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；</li> <li>嵌套函数中的 this 不会继承外层函数的 this 值。</li> <li>箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。</li></ul> <h3 id="四、-v8-工作原理"><a href="#四、-v8-工作原理" aria-hidden="true" class="header-anchor">#</a> 四、 V8 工作原理</h3> <h4 id="_1-数据是如何存储的？"><a href="#_1-数据是如何存储的？" aria-hidden="true" class="header-anchor">#</a> 1. 数据是如何存储的？</h4> <p>静态语言： 在使用之前需要确认其变量数据类型</p> <p>动态语言：在运行过程中检查数据类型</p> <p>隐式类型转换：在赋值过程中，把不同类型的变量悄悄转换，进行赋值；</p> <p>支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言</p> <p>js 是弱类型，动态语言</p> <p><img src="/blog/assets/img/51.6293f531.png" alt="10.jpeg"></p> <p>js 在执行过程中，主要有三种类型内存空间，分别为代码空间，栈空间，堆空间</p> <p>栈空间，将变量存储在调用栈中，仅原始类型的数据可以存储，速度块，效率高，体积小</p> <p>堆空间，将变量存储在堆内存中，引用类型的数据可以存储，体积很大，速度效率相对栈空间慢</p> <p>原始类型的赋值会完整复制比变量值，而引用类型的赋值是复制引用地址，如下图：</p> <p><img src="/blog/assets/img/52.51127624.png" alt="11.jpeg"></p> <p>再来回到闭包：产生闭包核心有两步：</p> <ul><li>预扫描内部函数</li> <li>把内部函数引用的外部变量保存到堆中，无论其类型。</li></ul> <h4 id="_2-垃圾数据是如何自动回收的"><a href="#_2-垃圾数据是如何自动回收的" aria-hidden="true" class="header-anchor">#</a> 2. 垃圾数据是如何自动回收的</h4> <p>数据分为两种，栈中的数据，堆中的数据</p> <p>调用栈中的数据是如何回收的？</p> <p>当一个函数执行完成之后，就需要销毁其执行上下文了，这时在调用栈中会有一个记录当前执行状态的指针，指针移动到下一层的执行上下文，当有新的执行上下文进来时，会覆盖掉指针上面的执行上下文，如图所示：</p> <p><img src="/blog/assets/img/53.b1f05732.png" alt="12.jpeg"></p> <p>堆中的数据时如何回收的？</p> <p>使用 js 的垃圾回收器</p> <p>V8 会把堆分为新生代和老生代两个区域，新生代存放生存时间短的对象，老生代中存放生存时间久的对象</p> <p>新生区小，支持 1 ～ 8M 的容量，老生区大很多</p> <p>副垃圾回收器，主要负责新生代的垃圾回收，主垃圾回收器，主要负责老生代的垃圾回收</p> <p>新生代中用 Scavenge 算法，把新生代空间对半划分为两个区域，一半对象区域一半空闲区域；新加入的对象都会放到对象区域，当对象区域快被写满时，执行一次垃圾清理操作。即标记清理，然后将存活的对象复制到空闲区域，同时把这些对象有序的排列起来，此时角色翻转，对象区域和空闲区域对调，以此无限循环下去</p> <p>对象晋升策略：由于新生区空间不大，存活的对象很容易装满整个区域，因此经过两次垃圾回收依然存活的对象，会被移动到老生区中</p> <p>老生区中的垃圾回收，除了新生区中晋升的对象，一些大的对象会直接分配到老生区，因此老生区对象有两个特点：</p> <ul><li>占用空间大</li> <li>存活时间长</li></ul> <p>老生区使用标记-清除（Mark-Sweep）算法，首先是标记，当函数退出后，调用栈中没有了对数据的引用，此数据被标记为垃圾数据，执行清除，清除后会产生大量不连续的生存碎片，碎片过多会导致大对象无法分配到足够的连续内存，因此还需要整理，所有存活的对象都向一端移动，</p> <h4 id="_3-编译器和解释器：v8-是如何执行一段-javascript-代码的"><a href="#_3-编译器和解释器：v8-是如何执行一段-javascript-代码的" aria-hidden="true" class="header-anchor">#</a> 3. 编译器和解释器：V8 是如何执行一段 javascript 代码的</h4> <p>编译型语言：在程序执行之前，会通过编译器进行编译，编译之后会直接保留机器能读懂的二进制文件，这样到执行阶段时，可以直接运行该二进制文件，而不需要重新编译了</p> <p>解释型语言：在每次运行时都需要通过解释器对程序进行动态解释和执行</p> <p><img src="/blog/assets/img/54.4e196603.png" alt="13.jpeg"></p> <p>如图：</p> <ul><li><p>编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析，语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</p></li> <li><p>在解释性语言的解释过程中，是逐行解释的，同样解释器也会对源代码进行词法分析，语法分析，并生成抽象语法树(AST)，不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序，输出结果。</p></li></ul> <p>javascript 执行过程：</p> <p><img src="/blog/assets/img/55.1af282bd.png" alt="14.jpeg"></p> <ul><li>生成抽象语法树(AST)和执行上下文；首先是分词（词法分析），然后是解析（语法分析）</li> <li>生成字节码；字节码是介于 AST 和机器码之间的一种代码，字节码需要解释器将其转换为机器码后才能执行</li> <li>执行代码：逐条解释执行，若一段代码被重复执行多次，后台的编译器会把这段代码编译为高效的机器码，当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，大大提升了代码的执行效率</li></ul> <p>这种字节码配合解释器和编译器称为即时编译。</p> <p><img src="/blog/assets/img/56.c401f7ed.png" alt="15.jpeg"></p> <p>因此 js 执行的性能优化有以下几点：</p> <p>单次脚本的执行时间；脚本的网络下载；</p> <ul><li>提升单次脚本的执行速度，避免 js 长任务霸占主线程</li> <li>避免大的内联脚本，因为在解析 html 的过程中， 解析和编译也会占用主线程</li> <li>减少 js 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">1/9/2020, 4:15:15 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.04a40249.js" defer></script><script src="/blog/assets/js/2.614c271f.js" defer></script><script src="/blog/assets/js/3.cabfff8b.js" defer></script>
  </body>
</html>
